#!/usr/bin/env bash

function __bash_prompt_last_exit_code {
  [[ $last_exit_code -gt 0 ]] || return 1;

  printf "%s" "$last_exit_code"
}

function __bash_prompt_ps1 {
  local slice_prefix slice_empty_prefix slice_joiner slice_suffix is_prompt_empty=1

  # section "a" header
  slice_prefix="${a_bg}${a_fg}${a_bg} " slice_suffix=" ${a_sep_fg}" slice_joiner="${a_fg}${a_bg}${alt_sep} " slice_empty_prefix="${a_fg}${a_bg} "
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "a" slices
  __bash_prompt_wrapper "$(printf "%s" \\u)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "b" header
  slice_prefix="${b_bg}${b_fg}${b_bg} " slice_suffix=" ${b_sep_fg}" slice_joiner="${b_fg}${b_bg}${alt_sep} " slice_empty_prefix="${b_fg}${b_bg} "
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "b" slices
  __bash_prompt_wrapper "$(__bash_prompt_cwd)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "c" header
  slice_prefix="${c_bg}${c_fg}${c_bg} " slice_suffix=" ${c_sep_fg}" slice_joiner="${c_fg}${c_bg}${alt_sep} " slice_empty_prefix="${c_fg}${c_bg} "
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "c" slices
  __bash_prompt_wrapper "$(__bash_prompt_vcs_branch)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "warn" header
  slice_prefix="${warn_bg}${warn_fg}${warn_bg} " slice_suffix=" ${warn_sep_fg}" slice_joiner="${warn_fg}${warn_bg}${alt_sep} " slice_empty_prefix="${warn_fg}${warn_bg} "
  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"
  # section "warn" slices
  __bash_prompt_wrapper "$(__bash_prompt_last_exit_code)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # close sections
  printf "%s" "${reset_bg}$reset "
}

function __bash_prompt_vcs_branch {
  local branch
  local branch_symbol="î‚  "

  # git
  if hash git 2>/dev/null; then
    if branch=$( { git symbolic-ref --quiet HEAD || git rev-parse --short HEAD; } 2>/dev/null ); then
      branch=${branch##*/}
      printf "%s" "${branch_symbol}${branch:-unknown}"
      return
    fi
  fi
  return 1
}

function __bash_prompt_cwd {
  local dir_limit="2"
  local truncation="â‹¯ "
  local first_char
  local part_count=0
  local formatted_cwd=""
  local dir_sep="/"
  local tilde="~"

  local cwd="${PWD/#$HOME/$tilde}"

  # get first char of the path, i.e. tilde or slash
  first_char=${cwd::1}

  # remove leading tilde
  cwd="${cwd#\~}"

  while [[ "$cwd" == */* && "$cwd" != "/" ]]; do
    # pop off last part of cwd
    local part="${cwd##*/}"
    cwd="${cwd%/*}"

    formatted_cwd="$dir_sep$part$formatted_cwd"
    part_count=$((part_count+1))

    [[ $part_count -eq $dir_limit ]] && first_char="$truncation" && break
  done

  printf "%s" "$first_char$formatted_cwd"
}

function __bash_prompt_wrapper {
  # wrap the text in $1 with $2 and $3, only if $1 is not empty
  # $2 and $3 typically contain non-content-text, like color escape codes and separators

  [[ -n "$1" ]] || return 1
  printf "%s" "${2}${1}${3}"
}

function __bash_prompt {
  local last_exit_code="${PROMPTLINE_LAST_EXIT_CODE:-$?}"

  local esc=$'[' end_esc=m
  local noprint='\[' end_noprint='\]'
  local wrap="$noprint$esc" end_wrap="$end_esc$end_noprint"
  local alt_sep="|"
  local reset="${wrap}0${end_wrap}"
  local reset_bg="${wrap}49${end_wrap}"
  local a_fg="${wrap}38;5;238${end_wrap}"
  local a_bg="${wrap}48;5;231${end_wrap}"
  local a_sep_fg="${wrap}38;5;231${end_wrap}"
  local b_fg="${wrap}38;5;255${end_wrap}"
  local b_bg="${wrap}48;5;67${end_wrap}"
  local b_sep_fg="${wrap}38;5;67${end_wrap}"
  local c_fg="${wrap}38;5;255${end_wrap}"
  local c_bg="${wrap}48;5;24${end_wrap}"
  local c_sep_fg="${wrap}38;5;24${end_wrap}"
  local warn_fg="${wrap}38;5;231${end_wrap}"
  local warn_bg="${wrap}48;5;64${end_wrap}"
  local warn_sep_fg="${wrap}38;5;64${end_wrap}"
  PS1="$(__bash_prompt_ps1)"
}

if [[ ! "$PROMPT_COMMAND" == *__bash_prompt* ]]; then
  PROMPT_COMMAND='__bash_prompt;'$'\n'"$PROMPT_COMMAND"
fi
